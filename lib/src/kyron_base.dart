// lib/src/kyron_base.dart

import 'dart:async';

import 'package:kyron/src/exceptions.dart';
import 'package:kyron/src/kyron_interface.dart';
import 'package:kyron/src/notification_dispatcher.dart';
import 'package:kyron/src/notification_handler.dart';
import 'package:kyron/src/notification_order.dart';
import 'package:kyron/src/pipeline_behavior.dart';
import 'package:kyron/src/pipeline_component_info.dart';
import 'package:kyron/src/pipeline_context.dart';
import 'package:kyron/src/pipeline_executor.dart';
import 'package:kyron/src/registry.dart';
import 'package:kyron/src/request.dart';
import 'package:kyron/src/request_handler.dart';
import 'package:logging/logging.dart';

/// Concrete implementation of [KyronInterface].
///
/// [Kyron] acts as the central orchestrator for processing requests and publishing
/// events/messages within an application. It promotes loose coupling by decoupling
/// the senders of requests/events from their handlers.
///
/// ## Core Responsibilities:
/// 1.  Registration: Provides methods ([registerHandler], [registerStreamHandler],
///     [registerBehavior], [registerNotificationHandler]) to register the components
///     that handle requests and events/messages, as well as the pipeline behaviors
///     (middleware) that intercept request processing.
/// 2.  Request Dispatching: Handles incoming requests ([Request]) via the [send]
///     method. It identifies the appropriate handler, constructs and executes a
///     pipeline of applicable behaviors around the handler call, and returns the
///     single response.
/// 3.  Stream Request Dispatching: Handles incoming stream requests ([StreamRequest])
///     via the [stream] method. It identifies the appropriate stream handler, executes
///     setup pipeline behaviors, and returns the [Stream] of responses generated by
///     the handler.
/// 4.  Event/Message Publishing: Handles outgoing events/messages of any type via
///     the [publish] method. It identifies all registered handlers for the specific
///     object type and invokes them in a defined order.
///
/// ## Internal Composition:
/// [Kyron] delegates specific tasks to internal components:
///   - [KyronRegistry]: Manages the storage and retrieval of registered handlers
///     and behaviors.
///   - [PipelineExecutor]: Responsible for building and executing the pipeline of
///     behaviors and the final handler for requests ([send]/[stream]).
///   - [NotificationDispatcher]: Responsible for dispatching notifications to all
///     their registered handlers.
final class Kyron implements KyronInterface {
  // Added Logger instance
  static final _log = Logger('Kyron');

  /// Creates a new [Kyron] instance.
  ///
  /// - [registry]: Optional custom registry for storing handlers/behaviors.
  /// - [executor]: Optional custom pipeline executor.
  /// - [dispatcher]: Optional custom notification dispatcher.
  /// - [notificationErrorStrategy]: Strategy for handling errors during notification
  ///   publishing via [publish]. Defaults to [NotificationErrorStrategy.continueOnError].
  ///   See [NotificationErrorStrategy] for options.
  ///
  /// **Customization:**
  /// While `Kyron` provides default implementations for its internal components,
  /// advanced users can provide custom instances of `MediatorRegistry`,
  /// `PipelineExecutor`, or `NotificationDispatcher` via the constructor to tailor
  /// the behavior (e.g., different pipeline execution strategies, custom registration
  /// storage, or different notification dispatch logic).
  ///
  /// {@tool snippet}
  /// **Example: Basic Setup and Usage**
  ///
  /// ```dart
  /// import 'package:kyron/kyron.dart';
  ///
  /// // Define simple request/response/handler
  /// class SimpleRequest extends Request<String> { final String message; SimpleRequest(this.message); }
  /// class SimpleHandler extends RequestHandler<SimpleRequest, String> {
  ///   @override Future<String> handle(SimpleRequest request, PipelineContext context) async {
  ///     return "Processed: ${request.message}";
  ///   }
  /// }
  ///
  /// // Define simple notification/handler
  /// class InfoNotification { final String info; InfoNotification(this.info); }
  /// class LoggingNotificationHandler extends NotificationHandler<InfoNotification> {
  ///   @override Future<void> handle(InfoNotification notification) async {
  ///     print("Notification Received: ${notification.info}");
  ///   }
  /// }
  ///
  /// Future<void> main() async {
  ///   // 1. Create the Kyron mediator instance
  ///   final kyron = Kyron();
  ///
  ///   // 2. Register components
  ///   kyron.registerHandler<SimpleRequest, String>(() => SimpleHandler());
  ///   kyron.registerNotificationHandler<InfoNotification>(() => LoggingNotificationHandler());
  ///
  ///   print("Kyron setup complete.");
  ///
  ///   // 3. Send a request
  ///   final response = await kyron.send(SimpleRequest("Hello Kyron!"));
  ///   print("Response from send: $response");
  ///
  ///   // 4. Publish a notification
  ///   await kyron.publish(InfoNotification("System started."));
  ///
  ///   print("Done.");
  /// }
  /// ```
  /// {@end-tool}
  ///
  /// See also:
  ///   - [KyronInterface] for the interface contract.
  ///   - [Request], [RequestHandler], [StreamRequest], [StreamRequestHandler] for request handling.
  ///   - [Notification], [NotificationHandler] for notification handling.
  ///   - [PipelineBehavior], [PipelineContext] for pipeline customization
  Kyron({
    KyronRegistry? registry,
    PipelineExecutor? executor,
    NotificationDispatcher? dispatcher,
    NotificationErrorStrategy notificationErrorStrategy =
        NotificationErrorStrategy.continueOnError,
  }) : _registry = registry ?? KyronRegistry(),
       _executor = executor ?? PipelineExecutor(),
       _dispatcher =
           dispatcher ??
           NotificationDispatcher(errorStrategy: notificationErrorStrategy) {
    _log.config('Kyron instance created.');
    _log.config('Using Registry: ${_registry.runtimeType}');
    _log.config('Using Executor: ${_executor.runtimeType}');
    _log.config('Using Dispatcher: ${_dispatcher.runtimeType}');
    _log.config(
      'Notification Error Strategy: ${notificationErrorStrategy.name}',
    );
  }

  final NotificationDispatcher _dispatcher;
  final KyronRegistry _registry;
  final PipelineExecutor _executor;

  /// Provides read-only access to the underlying registry for introspection purposes.
  /// Useful for debugging or building diagnostic tools.
  KyronRegistry get registry => _registry;

  // Registration Methods

  /// Registers a factory function responsible for creating or providing a handler
  /// for a specific request type ([TRequest]).
  ///
  /// When [send] is called with a request object of type [TRequest], the kyron
  /// will invoke the provided [handlerFactory] function to obtain an instance
  /// of the corresponding [RequestHandler<TRequest, TResponse>]. This handler
  /// instance will then be used to process the request.
  ///
  /// The use of a factory function ([handlerFactory]) instead of directly accepting
  /// a handler instance offers crucial advantages:
  ///
  /// *   **Lifecycle Management & Isolation:** It allows the creation of a **new**
  ///     handler instance for each incoming request. This is the recommended approach
  ///     for handlers that are not inherently stateless, as it prevents shared state
  ///     issues and ensures request isolation. Each request gets processed by a
  ///     handler instance unaffected by previous requests.
  /// *   **Dependency Injection Integration:** The factory function can encapsulate
  ///     logic to resolve the handler and its dependencies from a Dependency
  ///     Injection (DI) container or service locator *at the time the request
  ///     is processed*, rather than just at registration time. This ensures
  ///     dependencies have the correct scope and lifecycle.
  /// *   **Flexibility:** While typically used to create new instances, the factory
  ///     *can* be implemented to return a pre-existing singleton instance if that
  ///     specific handler is designed to be stateless and shared.
  ///
  /// **Generics:**
  ///   - [TRequest]: The specific type of the request message, which must extend
  ///     [Request<TResponse>].
  ///   - [TResponse]: The type of the response object expected when handling [TRequest].
  ///
  /// **Parameters:**
  ///   - [handlerFactory]: A zero-argument function (`()`) that returns an instance
  ///     of `RequestHandler<TRequest, TResponse>`. This function will be called
  ///     by kyron internally when a request of type [TRequest] needs handling.
  ///
  /// **Side Effects:**
  ///   - Stores the mapping between [TRequest] and the [handlerFactory] in the
  ///     internal registry.
  ///   - If a handler factory for the exact [TRequest] type is already registered,
  ///     it will be **overwritten** by this new registration, and a warning
  ///     may be printed to the console.
  ///
  /// {@tool snippet}
  /// **Example 1: Basic Handler Registration**
  ///
  /// ```dart
  /// // Define the Request and Response
  /// class GetUserQuery extends Request<User> {
  ///   final int userId;
  ///   GetUserQuery(this.userId);
  /// }
  /// class User {
  ///   final int id;
  ///   final String name;
  ///   User(this.id, this.name);
  ///   @override String toString() => 'User(id: $id, name: $name)';
  /// }
  ///
  /// // Define the Handler
  /// class GetUserQueryHandler extends RequestHandler<GetUserQuery, User> {
  ///   @override
  ///   Future<User> handle(GetUserQuery request, PipelineContext context) async {
  ///     print("Handler: Fetching user ${request.userId}");
  ///     // Simulate fetching data
  ///     await Future.delayed(Duration(milliseconds: 10));
  ///     return User(request.userId, 'Example User ${request.userId}');
  ///   }
  /// }
  ///
  /// // Registration
  /// final kyron = Kyron();
  ///
  /// // Register the factory. A new GetUserQueryHandler is created per request.
  /// kyron.registerHandler<GetUserQuery, User>(
  ///   () => GetUserQueryHandler(),
  /// );
  /// print('GetUserQueryHandler registered using a factory.');
  ///
  /// // Usage
  /// final user = await kyron.send(GetUserQuery(123));
  /// print('Received: $user');
  /// final user2 = await kyron.send(GetUserQuery(456)); // Gets a new handler instance
  /// print('Received: $user2');
  /// ```
  /// {@end-tool}
  ///
  /// {@tool snippet}
  /// **Example 2: Handler with Dependencies (Conceptual)**
  ///
  /// ```dart
  /// // Assume IUserService exists
  /// abstract class IUserService { Future<String> getUserName(int id); }
  /// class RealUserService implements IUserService {
  ///   @override Future<String> getUserName(int id) async => 'Real Name $id';
  /// }
  ///
  /// class GetUserQueryHandlerWithDep extends RequestHandler<GetUserQuery, User> {
  ///   final IUserService _userService;
  ///
  ///   // Handler depends on IUserService
  ///   GetUserQueryHandlerWithDep(this._userService);
  ///
  ///   @override
  ///   Future<User> handle(GetUserQuery request, PipelineContext context) async {
  ///     final name = await _userService.getUserName(request.userId);
  ///     return User(request.userId, name);
  ///   }
  /// }
  ///
  /// // Registration using a factory that resolves dependencies
  /// // (Simplified - replace with your actual DI container logic if used)
  /// IUserService myUserService = RealUserService(); // Or resolve from container
  ///
  /// kyron.registerHandler<GetUserQuery, User>(
  ///   // The factory creates the handler AND injects its dependency
  ///   () => GetUserQueryHandlerWithDep(myUserService), // Or container.resolve<IUserService>()
  /// );
  /// print('GetUserQueryHandlerWithDep registered using a factory with dependency resolution.');
  ///
  /// // Usage (same as before)
  /// final user = await kyron.send(GetUserQuery(789));
  /// print('Received: $user');
  /// ```
  /// {@end-tool}
  ///
  /// {@tool snippet}
  /// **Example 3: Registering a Singleton Handler (Less Common Use Case)**
  ///
  /// This is only appropriate if `MySingletonHandler` is truly stateless.
  ///
  /// ```dart
  /// class MySingletonHandler extends RequestHandler<GetUserQuery, User> {
  ///   // Private constructor for singleton pattern
  ///   MySingletonHandler._();
  ///   static final MySingletonHandler instance = MySingletonHandler._();
  ///
  ///   @override
  ///   Future<User> handle(GetUserQuery request, PipelineContext context) async {
  ///     print("Singleton Handler: Processing user ${request.userId}");
  ///     return User(request.userId, 'Singleton User ${request.userId}');
  ///   }
  /// }
  ///
  /// // Registration
  /// // The factory always returns the *same* pre-existing instance.
  /// kyron.registerHandler<GetUserQuery, User>(
  ///   () => MySingletonHandler.instance,
  /// );
  /// print('MySingletonHandler registered as a singleton via factory.');
  ///
  /// // Usage
  /// // Both calls will use the exact same MySingletonHandler.instance
  /// final userA = await kyron.send(GetUserQuery(1));
  /// print('Received: $userA');
  /// final userB = await kyron.send(GetUserQuery(2));
  /// print('Received: $userB');
  /// ```
  /// {@end-tool}
  void registerHandler<TRequest extends Request<TResponse>, TResponse>(
    RequestHandler<TRequest, TResponse> Function() handlerFactory,
  ) {
    try {
      _registry.registerHandler<TRequest, TResponse>(handlerFactory);
      // log moved to registry
    } catch (e, s) {
      _log.severe('Failed to register handler for $TRequest. Error: $e', e, s);
      // Rethrow or wrap if registry doesn't throw specific MediatorConfigurationException
      if (e is! MediatorConfigurationException) {
        throw MediatorConfigurationException(
          'Failed to register handler for $TRequest. Inner Error: $e',
        );
      } else {
        rethrow;
      }
    }
  }

  /// Registers a factory function responsible for creating or providing a handler
  /// for a specific stream request type ([TRequest]) that yields multiple responses.
  ///
  /// When [stream] is called with a request object of type [TRequest], kyron
  /// will invoke the provided [handlerFactory] function to obtain an instance
  /// of the corresponding [StreamRequestHandler<TRequest, TResponse>]. This handler
  /// instance will then be used to process the request and generate the response stream.
  ///
  /// Similar to [registerHandler], the use of a factory function ([handlerFactory])
  /// is the standard approach:
  ///
  /// *   **Lifecycle Management & Isolation:** Enables creating a new handler instance
  ///     per stream request, preventing state conflicts if the handler is stateful.
  /// *   **Dependency Injection Integration:** Allows resolving the handler and its
  ///     dependencies from a DI container when the request is processed.
  /// *   **Flexibility:** Can return a shared singleton instance if the handler is
  ///     designed to be stateless and shared.
  ///
  /// **Generics:**
  ///   - [TRequest]: The specific type of the stream request message, which must extend
  ///     [StreamRequest<TResponse>].
  ///   - [TResponse]: The type of items expected in the response [Stream].
  ///
  /// **Parameters:**
  ///   - [handlerFactory]: A zero-argument function (`()`) that returns an instance
  ///     of `StreamRequestHandler<TRequest, TResponse>`. This function will be called
  ///     by kyron internally when a request of type [TRequest] needs handling.
  ///
  /// **Side Effects:**
  ///   - Stores the mapping between [TRequest] and the [handlerFactory] in the
  ///     internal registry for stream handlers.
  ///   - If a stream handler factory for the exact [TRequest] type is already registered,
  ///     it will be **overwritten** by this new registration, and a warning
  ///     may be printed to the console.
  ///
  /// {@tool snippet}
  /// **Example: Basic Stream Handler Registration**
  ///
  /// ```dart
  /// // Define the Stream Request and Response Type (item type)
  /// class GetCounterUpdates extends StreamRequest<int> {
  ///   final int startValue;
  ///   final int count;
  ///   GetCounterUpdates(this.startValue, this.count);
  /// }
  ///
  /// // Define the Stream Handler
  /// class GetCounterUpdatesHandler
  ///     extends StreamRequestHandler<GetCounterUpdates, int> {
  ///   @override
  ///   Stream<int> handle(GetCounterUpdates request, PipelineContext context) async* {
  ///     print("Stream Handler: Starting count from ${request.startValue}");
  ///     for (int i = 0; i < request.count; i++) {
  ///       await Future.delayed(Duration(milliseconds: 200)); // Simulate work
  ///       final value = request.startValue + i;
  ///       print("Stream Handler: Yielding $value");
  ///       yield value;
  ///     }
  ///     print("Stream Handler: Finished counting.");
  ///   }
  /// }
  ///
  /// // Registration
  /// final kyron = Kyron();
  ///
  /// // Register the factory. A new GetCounterUpdatesHandler is created per request.
  /// kyron.registerStreamHandler<GetCounterUpdates, int>(
  ///   () => GetCounterUpdatesHandler(),
  /// );
  /// print('GetCounterUpdatesHandler registered using a factory.');
  ///
  /// // Usage (Conceptual - how you would listen)
  /// print('Starting stream request...');
  /// final stream = kyron.stream(GetCounterUpdates(10, 5));
  ///
  /// await for (final value in stream) {
  ///   print('Received from stream: $value');
  /// }
  /// print('Stream finished.');
  /// ```
  /// {@end-tool}
  void registerStreamHandler<
    TRequest extends StreamRequest<TResponse>,
    TResponse
  >(StreamRequestHandler<TRequest, TResponse> Function() handlerFactory) {
    try {
      _registry.registerStreamHandler<TRequest, TResponse>(handlerFactory);
    } catch (e, s) {
      _log.severe(
        'Failed to register stream handler for $TRequest. Error: $e',
        e,
        s,
      );
      // Rethrow or wrap if registry doesn't throw specific MediatorConfigurationException
      if (e is! MediatorConfigurationException) {
        throw MediatorConfigurationException(
          'Failed to register stream handler for $TRequest. Inner Error: $e',
        );
      } else {
        rethrow;
      }
    }
  }

  /// Registers a factory function responsible for creating or providing a
  /// pipeline behavior (middleware) instance.
  ///
  /// Pipeline behaviors intercept requests ([Request] and [StreamRequest]) before
  /// they reach their handler, allowing for cross-cutting concerns like logging,
  /// validation, caching, authorization, etc., to be implemented cleanly.
  /// Behaviors are executed in a defined order.
  ///
  /// The use of a factory function ([behaviorFactory]) is consistent with handler
  /// registration, providing benefits for lifecycle management and dependency injection.
  ///
  /// **Applicability:**
  ///   - By default (if `appliesTo` is `null`), the behavior's applicability is
  ///     determined by the type argument `<TRequest>` used when calling
  ///     `_registry.registerBehavior` internally (which is currently fixed to `BaseRequest`,
  ///     making it global). *Future versions might refine this inference.*
  ///   - **Using `appliesTo`:** You can provide a custom [BehaviorPredicate] function
  ///     to precisely control which requests this behavior should run for. This is
  ///     the recommended way to apply behaviors to specific request types or requests
  ///     meeting certain criteria (e.g., implementing a marker interface).
  ///
  /// **Execution Order:**
  ///   - Behaviors are executed in ascending order based on their `order` property.
  ///     Lower numbers run earlier (wrap outer layers).
  ///   - The `orderOverride` parameter allows you to specify an execution order
  ///     explicitly during registration, taking precedence over the `order` getter
  ///     defined within the behavior class itself. This is useful for dynamically
  ///     adjusting order without modifying the behavior class.
  ///   - If multiple behaviors have the same order, their relative execution sequence
  ///     within that order group is determined by their registration sequence.
  ///
  /// **Parameters:**
  ///   - [behaviorFactory]: A zero-argument function (`()`) that returns an instance
  ///     of a class implementing `PipelineBehavior<dynamic, dynamic>`. Kyron
  ///     will call this factory when constructing the pipeline for an applicable request.
  ///     The actual request/response types are handled internally during execution.
  ///   - [appliesTo]: An optional function `bool Function(Object request)` that
  ///     takes the request object and returns `true` if the behavior should be
  ///     applied to this request, `false` otherwise. If `null`, default applicability
  ///     rules apply (currently global unless registry inference changes).
  ///   - [orderOverride]: An optional integer to explicitly set the execution order,
  ///     overriding the behavior's `order` getter.
  ///
  /// **Side Effects:**
  ///   - Adds the behavior registration details (factory, predicate, order) to an
  ///     internal list in the registry. Behaviors are **added**, not overwritten;
  ///     multiple behaviors can be registered and will execute if applicable.
  ///
  /// {@tool snippet}
  /// **Example 1: Global Logging Behavior**
  ///
  /// ```dart
  /// // Assume Request/Handler definitions exist (e.g., GetUserQuery from previous examples)
  ///
  /// class LoggingBehavior extends PipelineBehavior<BaseRequest, dynamic> {
  ///   @override
  ///   int get order => -10; // Run early
  ///
  ///   @override
  ///   Future<dynamic> handle(BaseRequest request, PipelineContext context,
  ///       RequestHandlerDelegate<dynamic> next) async {
  ///     final stopwatch = Stopwatch()..start();
  ///     print('[Behavior:Log] START Processing ${request.runtimeType}');
  ///     try {
  ///       final response = await next(); // Call the next step in the pipeline
  ///       stopwatch.stop();
  ///       print(
  ///         '[Behavior:Log] END Processing ${request.runtimeType}. Duration: ${stopwatch.elapsedMilliseconds}ms',
  ///       );
  ///       return response;
  ///     } catch (e) {
  ///       stopwatch.stop();
  ///       print(
  ///         '[Behavior:Log] FAILED Processing ${request.runtimeType}. Duration: ${stopwatch.elapsedMilliseconds}ms. Error: $e',
  ///       );
  ///       rethrow;
  ///     }
  ///   }
  /// }
  ///
  /// // Registration (Globally - appliesTo is null)
  /// final kyron = Kyron();
  /// kyron.registerBehavior(
  ///   () => LoggingBehavior(),
  ///   // No appliesTo means global (based on current internal registry call)
  /// );
  /// print('LoggingBehavior registered globally.');
  ///
  /// // (Register handlers needed for the requests you send)
  /// // kyron.registerHandler<GetUserQuery, User>(...)
  ///
  /// // Usage (LoggingBehavior will run for this)
  /// // await kyron.send(GetUserQuery(1));
  /// ```
  /// {@end-tool}
  ///
  /// {@tool snippet}
  /// **Example 2: Specific Validation Behavior with Predicate and Order Override**
  ///
  /// ```dart
  /// // Assume CreateOrderCommand exists
  /// class CreateOrderCommand extends Request<String> { final int amount; CreateOrderCommand(this.amount); }
  /// class ValidationException implements Exception { final String message; ValidationException(this.message); }
  ///
  /// class ValidationBehavior extends PipelineBehavior<CreateOrderCommand, String> {
  ///   // Default order, can be overridden
  ///   @override int get order => 0;
  ///
  ///   @override
  ///   Future<String> handle(CreateOrderCommand request, PipelineContext context,
  ///       RequestHandlerDelegate<String> next) async {
  ///     print('[Behavior:Validate] Validating ${request.runtimeType}');
  ///     if (request.amount <= 0) {
  ///       print('[Behavior:Validate] FAILED: Amount must be positive.');
  ///       throw ValidationException('Amount must be positive.');
  ///     }
  ///     print('[Behavior:Validate] PASSED.');
  ///     return await next(); // Proceed only if validation passes
  ///   }
  /// }
  ///
  /// // Registration (Specific Request Type using appliesTo, custom order)
  /// kyron.registerBehavior(
  ///   () => ValidationBehavior(),
  ///   // Predicate checks for the specific request type
  ///   appliesTo: (request) => request is CreateOrderCommand,
  ///   orderOverride: 5, // Ensure it runs after logging (order -10) but before others
  /// );
  /// print('ValidationBehavior registered for CreateOrderCommand with order 5.');
  ///
  /// // (Register handler for CreateOrderCommand)
  /// // kyron.registerHandler<CreateOrderCommand, String>(...)
  ///
  /// // Usage
  /// // ValidationBehavior will run for this:
  /// // try { await kyron.send(CreateOrderCommand(100)); } catch (e) { print(e); }
  /// // ValidationBehavior will run and throw for this:
  /// // try { await kyron.send(CreateOrderCommand(-5)); } catch (e) { print(e); }
  /// // ValidationBehavior will NOT run for this (assuming GetUserQuery is different):
  /// // await kyron.send(GetUserQuery(2));
  /// ```
  /// {@end-tool}
  void registerBehavior(
    PipelineBehavior<dynamic, dynamic> Function() behaviorFactory, {
    BehaviorPredicate? appliesTo,
    String? predicateDescription,
    int? orderOverride,
  }) {
    try {
      // Delegate to the registry's generic method.
      // Pass general types; registry infers/checks specific types internally.
      _registry.registerBehavior<BaseRequest, dynamic>(
        behaviorFactory,
        appliesTo: appliesTo,
        predicateDescription: predicateDescription,
        orderOverride: orderOverride,
      );
    } catch (e, s) {
      _log.severe('Failed to register pipeline behaviour. Error: $e', e, s);
      // Rethrow or wrap if registry doesn't throw specific MediatorConfigurationException
      if (e is! MediatorConfigurationException) {
        throw MediatorConfigurationException(
          'Failed to register pipeline behaviour. Inner Error: $e',
        );
      } else {
        rethrow;
      }
    }
  }

  /// Registers a factory function responsible for creating or providing a handler
  /// for a specific message/event type ([TNotification]).
  ///
  /// When [publish] is called with an object of type [TNotification],
  /// the [Kyron] will find all registered handlers for that type. For each
  /// registration, it invokes the provided [handlerFactory] function to obtain an
  /// instance of the corresponding [NotificationHandler<TNotification>]. These handler
  /// instances are then executed according to their specified [order] to process
  /// the message/event.
  ///
  /// The use of a factory function ([handlerFactory]) instead of directly accepting
  /// a handler instance offers crucial advantages:
  /// *   **Lifecycle Management & Isolation:** Allows creating new handler instances per message/event if needed.
  /// *   **Dependency Injection Integration:** Encapsulates resolving the handler and its dependencies.
  /// *   **Flexibility:** Can return singletons if the handler is stateless.
  ///
  /// **Multiple Handlers:** Unlike requests ([send]/[stream]), a single message/event
  /// type can have **multiple** registered handlers. All applicable handlers will
  /// be executed when the object is published.
  ///
  /// **Execution Order & Behavior:**
  ///   - The [order] parameter controls both the execution sequence and model
  ///     (parallel or sequential) for handlers processing the *same* [TNotification] type.
  ///   - Execution occurs in up to three distinct phases, based on the [order] values used:
  ///     1.  **Early Parallel Phase:** All handlers registered with [order]: [NotificationOrder.parallelEarly]
  ///         (which is the **default** if no [order] is provided) are executed concurrently
  ///         using [Future.wait]. This phase completes before the sequential phase begins.
  ///         Ideal for quick, independent tasks like logging.
  ///     2.  **Sequential Phase:** Handlers registered with specific integer orders (e.g., -10,
  ///         [NotificationOrder.sequentialDefault] which is 0, 5, 100) are executed sequentially
  ///         based on their numerical order (ascending, lower numbers first). This phase runs
  ///         *after* the early parallel phase and *before* the late parallel phase. Essential
  ///         for ordered workflows or dependent handlers. Handlers with the *same* sequential
  ///         order number maintain their relative registration sequence within that group.
  ///     3.  **Late Parallel Phase:** All handlers registered with [order]: [NotificationOrder.parallelLate]
  ///         are executed concurrently using [Future.wait]. This phase runs *after* the
  ///         sequential phase completes. Suitable for background or cleanup tasks.
  ///   - Use constants from the [NotificationOrder] class (e.g., [NotificationOrder.parallelEarly],
  ///     [NotificationOrder.sequentialDefault], [NotificationOrder.parallelLate]) for clarity
  ///     and indicating intent when registering handlers.
  ///
  /// **Error Handling:** Behavior depends on the [NotificationErrorStrategy] configured
  /// during [Kyron] instantiation (defaults to [NotificationErrorStrategy.continueOnError]).
  /// See [NotificationDispatcher] documentation for details on how errors are handled
  /// in both sequential and parallel execution phases.
  ///
  /// **Generics:**
  ///   - [TNotification]: The specific type of the message/event object.
  ///
  /// **Parameters:**
  ///   - [handlerFactory]: A zero-argument function (`()`) that returns an instance
  ///     of [NotificationHandler<TNotification>].
  ///   - [order]: An integer specifying the execution phase and sequence relative to
  ///     other handlers for the same message/event type. Defaults to
  ///     [NotificationOrder.parallelEarly]. See [NotificationOrder] for details on
  ///     constant values and their corresponding execution behavior.
  ///
  /// **Side Effects:**
  ///   - Adds the notification handler registration details (factory, order) to an
  ///     internal list associated with the [TNotification] type in the registry.
  ///
  /// {@tool snippet}
  /// **Example: Registering Mixed Execution Handlers**
  ///
  /// ```dart
  /// import 'package:kyron/kyron.dart'; // Assuming kyron.dart exports NotificationOrder
  ///
  /// // Define the Event/Message object (Plain Dart class)
  /// class OrderPlaced {
  ///   final int orderId;
  ///   OrderPlaced(this.orderId);
  /// }
  ///
  /// // Define Handlers (Implement NotificationHandler<OrderPlaced>)
  /// class LogOrderHandler extends NotificationHandler<OrderPlaced> { // Runs early, parallel (Default)
  ///   @override Future<void> handle(OrderPlaced n) async {
  ///     await Future.delayed(Duration(milliseconds: 10)); // Simulate work
  ///     print('[PARALLEL EARLY] Logging order ${n.orderId}');
  ///   }
  /// }
  ///
  /// class UpdateInventoryHandler extends NotificationHandler<OrderPlaced> { // Runs sequentially
  ///   @override Future<void> handle(OrderPlaced n) async {
  ///     await Future.delayed(Duration(milliseconds: 100)); // Simulate work
  ///     print('[SEQUENTIAL 10] Updating inventory for order ${n.orderId}');
  ///   }
  /// }
  ///
  /// class ChargePaymentHandler extends NotificationHandler<OrderPlaced> { // Runs sequentially after inventory
  ///   @override Future<void> handle(OrderPlaced n) async {
  ///     await Future.delayed(Duration(milliseconds: 50)); // Simulate work
  ///     print('[SEQUENTIAL 20] Charging payment for order ${n.orderId}');
  ///   }
  /// }
  ///
  /// class SendConfirmationEmailHandler extends NotificationHandler<OrderPlaced> { // Runs late, parallel
  ///   @override Future<void> handle(OrderPlaced n) async {
  ///     await Future.delayed(Duration(milliseconds: 200)); // Simulate work
  ///     print('[PARALLEL LATE] Sending confirmation email for order ${n.orderId}');
  ///   }
  /// }
  ///
  /// class UpdateAnalyticsHandler extends NotificationHandler<OrderPlaced> { // Runs late, parallel
  ///   @override Future<void> handle(OrderPlaced n) async {
  ///     await Future.delayed(Duration(milliseconds: 80)); // Simulate work
  ///     print('[PARALLEL LATE] Updating analytics for order ${n.orderId}');
  ///   }
  /// }
  ///
  /// // Registration
  /// final kyron = Kyron(); // Assuming default error strategy
  ///
  /// // Default order is parallelEarly
  /// kyron.registerNotificationHandler<OrderPlaced>(() => LogOrderHandler());
  /// print('LogOrderHandler registered (Default: Parallel Early)');
  ///
  /// // Specific sequential orders
  /// kyron.registerNotificationHandler<OrderPlaced>(
  ///   () => UpdateInventoryHandler(),
  ///   order: 10, // Explicit sequential order
  /// );
  /// print('UpdateInventoryHandler registered (Sequential order 10)');
  ///
  /// kyron.registerNotificationHandler<OrderPlaced>(
  ///   () => ChargePaymentHandler(),
  ///   order: 20, // Explicit sequential order, runs after inventory
  /// );
  /// print('ChargePaymentHandler registered (Sequential order 20)');
  ///
  /// // Late parallel handlers using the constant
  /// kyron.registerNotificationHandler<OrderPlaced>(
  ///   () => SendConfirmationEmailHandler(),
  ///   order: NotificationOrder.parallelLate,
  /// );
  /// print('SendConfirmationEmailHandler registered (Parallel Late)');
  ///
  /// kyron.registerNotificationHandler<OrderPlaced>(
  ///   () => UpdateAnalyticsHandler(),
  ///   order: NotificationOrder.parallelLate,
  /// );
  /// print('UpdateAnalyticsHandler registered (Parallel Late)');
  ///
  /// // Usage
  /// print('\nPublishing OrderPlaced event/message...');
  /// await kyron.publish(OrderPlaced(123));
  /// print('Finished publishing.');
  ///
  /// // Expected Output Pattern:
  /// // - LogOrderHandler starts/finishes quickly (potentially interleaved).
  /// // - UpdateInventoryHandler starts/finishes.
  /// // - ChargePaymentHandler starts/finishes.
  /// // - SendConfirmationEmailHandler and UpdateAnalyticsHandler start concurrently
  /// //   and finish in whatever order their simulated work takes.
  /// ```
  /// {@end-tool}
  void registerNotificationHandler<TNotification>(
    NotificationHandler<TNotification> Function() handlerFactory, {
    int order = NotificationOrder.parallelEarly,
  }) {
    try {
      _registry.registerNotificationHandler<TNotification>(
        handlerFactory,
        order: order,
      );
    } catch (e, s) {
      _log.severe(
        'Failed to register notification for $TNotification. Error: $e',
        e,
        s,
      );
      // Rethrow or wrap if registry doesn't throw specific MediatorConfigurationException
      if (e is! MediatorConfigurationException) {
        throw MediatorConfigurationException(
          'Failed to register notification for $TNotification. Inner Error: $e',
        );
      } else {
        rethrow;
      }
    }
  }

  // Execution Methods

  /// Sends a request object expecting a single response through the
  /// registered pipeline behaviors (if any) to its corresponding handler.
  ///
  /// - [request]: The request object implementing [Request<TResponse>].
  /// - Returns: A Future containing the response object [TResponse].
  /// - Throws: [UnregisteredHandlerException] if no handler is found for the request type.
  /// - Throws: [MediatorConfigurationException] for issues during setup
  ///   (e.g., behavior/handler instantiation failure).
  /// - Throws: [PipelineExecutionException] if an unhandled error occurs within
  ///   a [PipelineBehavior] or the [RequestHandler] during execution. Check the
  ///   [PipelineExecutionException.innerException] for the original error.
  /// - Throws: User-defined exceptions derived from [ShortCircuitException] if a
  ///   behavior intentionally stops the pipeline (e.g., validation failure).
  @override
  Future<TResponse> send<TResponse>(Request<TResponse> request) async {
    final requestType = request.runtimeType;
    final correlationId = request.hashCode;
    _log.info('Received request (send) [$correlationId] of type $requestType.');

    try {
      // 1. Find Handler Factory
      final handlerFactory = _registry.findHandlerFactory(requestType);
      if (handlerFactory == null) {
        _log.warning(
          'No handler factory found for $requestType [$correlationId].',
        );
        throw UnregisteredHandlerException(requestType);
      }
      _log.fine('Found handler factory for $requestType [$correlationId].');

      // 2. Create Context
      final context = PipelineContext(correlationId);
      _log.fine('Created PipelineContext instance [$correlationId].');

      // 3. Find, Sort, and Instantiate Behaviors
      final applicableRegistrations = _registry
          .findApplicableBehaviorRegistrations(request);
      applicableRegistrations.sort((a, b) => a.order.compareTo(b.order));
      _log.finer(
        'Found ${applicableRegistrations.length} applicable behavior registrations for $requestType [$correlationId]. Sorted by order.',
      );

      final sortedBehaviors = _executor.instantiateBehaviors(
        request,
        applicableRegistrations,
        correlationId,
      );

      RequestHandler<Request<TResponse>, TResponse> handler;
      try {
        // Cast is necessary here based on how factories are stored
        handler =
            handlerFactory() as RequestHandler<Request<TResponse>, TResponse>;
        _log.fine(
          'Instantiated handler: ${handler.runtimeType} for $requestType [$correlationId].',
        );
      } catch (e, s) {
        _log.severe(
          'Error instantiating handler for $requestType [$correlationId] from factory. Error: $e',
          e,
          s,
        );
        throw MediatorConfigurationException(
          'Failed to instantiate handler for $requestType [$correlationId]. Inner Error: $e',
        );
      }

      // 5. Build Pipeline Delegate
      final pipelineDelegate = _executor.buildPipelineDelegate<TResponse>(
        handler,
        sortedBehaviors,
        request,
        context,
        correlationId,
      );

      // 6. Execute Pipeline
      final response = await _executor.executeFuture<TResponse>(
        pipelineDelegate,
        correlationId,
        requestType,
      );
      return response;
    } on UnregisteredHandlerException catch (e) {
      // Logged where thrown, just rethrow
      _log.warning('Request failed: $e');
      rethrow;
    } on MediatorConfigurationException catch (e) {
      // Logged where thrown, just rethrow
      _log.severe('Request failed due to configuration error: $e');
      rethrow;
    } on PipelineExecutionException catch (e) {
      // Already logged/wrapped by executor, just rethrow
      _log.severe(
        'Request failed during pipeline execution: ${e.innerException} in ${e.originatingComponentType}',
      );
      rethrow;
    } on ShortCircuitException catch (e) {
      // Already logged by executor, just rethrow
      _log.info('Request short-circuited: ${e.runtimeType}');
      rethrow;
    } catch (e, s) {
      // Catch any other unexpected errors during the orchestration itself
      _log.severe(
        'Unexpected error during orchestration for request $requestType [$correlationId]. Error: $e',
        e,
        s,
      );
      // Wrap in a generic exception or rethrow; consider if PipelineExecutionException makes sense here
      // For now, rethrow to let the caller see the raw error.
      rethrow;
    }
  }

  /// Sends a request object expecting a stream of responses through the
  /// registered pipeline behaviors (if any) to its corresponding handler.
  ///
  /// Note: Pipeline behaviors execute *before* the stream is returned.
  /// They do not typically intercept individual stream events in this model.
  ///
  /// The returned stream will emit an error if setup fails.
  ///
  /// - Returns: A [Stream] emitting responses or an error if setup fails.
  /// - Possible Setup Errors (emitted via Stream.error):
  ///   - [UnregisteredHandlerException] if no handler is found.
  ///   - [MediatorConfigurationException] for issues during setup
  ///     (e.g., behavior/handler instantiation failure).
  ///   - [PipelineExecutionException] if an unhandled error occurs *during the setup phase*
  ///     within a [PipelineBehavior] or the [StreamRequestHandler] instantiation.
  ///   - User-defined exceptions derived from [ShortCircuitException] if a
  ///     behavior intentionally stops the setup phase.
  @override
  Stream<TResponse> stream<TResponse>(StreamRequest<TResponse> request) {
    final requestType = request.runtimeType;
    final correlationId = request.hashCode;
    _log.info(
      'Received request (stream) [$correlationId] of type $requestType.',
    );

    try {
      // 1. Find Stream Handler Factory
      final handlerFactory = _registry.findStreamHandlerFactory(requestType);
      if (handlerFactory == null) {
        _log.warning(
          'No stream handler factory found for $requestType [$correlationId]. Throwing UnregisteredHandlerException.',
        );
        throw UnregisteredHandlerException(requestType);
      }
      _log.fine(
        'Found stream handler factory for $requestType [$correlationId].',
      );

      // 2. Create Context
      final context = PipelineContext(correlationId);
      _log.fine('Created PipelineContext instance [$correlationId].');

      // 3. Find, Sort, and Instantiate Behaviors
      final applicableRegistrations = _registry
          .findApplicableBehaviorRegistrations(request);
      applicableRegistrations.sort((a, b) => a.order.compareTo(b.order));
      _log.finer(
        'Found ${applicableRegistrations.length} applicable behavior registrations for $requestType [$correlationId]. Sorted by order.',
      );
      final sortedBehaviors = _executor.instantiateBehaviors(
        request,
        applicableRegistrations,
        correlationId,
      );

      // 4. Instantiate Stream Handler
      StreamRequestHandler<StreamRequest<TResponse>, TResponse> handler;
      try {
        handler =
            handlerFactory()
                as StreamRequestHandler<StreamRequest<TResponse>, TResponse>;
        _log.fine(
          'Instantiated stream handler: ${handler.runtimeType} for $requestType [$correlationId].',
        );
      } catch (e, s) {
        _log.severe(
          'Error instantiating stream handler for $requestType [$correlationId] from factory. Error: $e',
          e,
          s,
        );
        throw MediatorConfigurationException(
          'Failed to instantiate stream handler for $requestType [$correlationId]. Inner Error: $e',
        );
      }

      // 5. Build Stream Pipeline Delegate Builder
      final pipelineStreamBuilder = _executor
          .buildStreamPipelineDelegate<TResponse>(
            handler,
            sortedBehaviors,
            request,
            context,
            correlationId,
          );

      // 6. Execute Stream Builder (starts async setup)
      // Executor handles synchronous builder errors and returns stream
      final resultStream = _executor.executeStream<TResponse>(
        pipelineStreamBuilder,
        correlationId,
        requestType,
      );
      return resultStream;
    } on UnregisteredHandlerException catch (e) {
      _log.warning('Stream request setup failed: $e');
      return Stream.error(e, StackTrace.current);
    } on MediatorConfigurationException catch (e) {
      _log.severe('Stream request setup failed due to configuration error: $e');
      return Stream.error(e, StackTrace.current);
    } catch (e, s) {
      // Catch sync errors during orchestration before async setup starts
      _log.severe(
        'Unexpected synchronous error during stream orchestration for $requestType [$correlationId]. Error: $e',
        e,
        s,
      );
      return Stream.error(e, s);
    }
  }

  /// Publishes an event/message object to all registered handlers for that
  /// specific object type. Execution order depends on registration order
  /// (if specified) and the dispatcher implementation.
  ///
  /// Behavior depends on the [NotificationErrorStrategy] configured during
  /// Kyron instantiation. See [NotificationDispatcher] documentation.
  ///
  /// - [notification]: The event/message object of type [TNotification] to publish.
  /// - Returns: A Future that completes when all handlers have been attempted
  ///   (subject to the error strategy). The Future typically completes successfully
  ///   unless using [NotificationErrorStrategy.collectErrors].
  /// - Throws: [AggregateException] if the strategy is
  ///   [NotificationErrorStrategy.collectErrors] and one or more handlers failed.
  ///   Other strategies usually log errors internally and do not throw from this method.
  @override
  Future<void> publish<TNotification>(TNotification notification) async {
    final notificationType = notification.runtimeType;
    final correlationId = notification.hashCode;
    _log.info(
      'Publishing notification/event [$correlationId] of type $notificationType.',
    );

    // 1. Find Handlers
    final handlerRegistrations = _registry.findNotificationHandlerRegistrations(
      notificationType,
    );

    if (handlerRegistrations.isEmpty) {
      _log.fine(
        'No notification handlers found for $notificationType [$correlationId].',
      );
      return;
    }

    // 2. Sort Handlers (Important for deterministic order)
    // Sort by order specified during registration
    handlerRegistrations.sort((a, b) => a.order.compareTo(b.order));
    _log.finer(
      'Found ${handlerRegistrations.length} notification handlers for $notificationType [$correlationId]. Sorted by order.',
    );

    // 3. Dispatch via NotificationDispatcher
    try {
      await _dispatcher.dispatch(
        notification,
        handlerRegistrations,
        correlationId: correlationId,
      );
    } on AggregateException {
      // Logged by dispatcher, just rethrow if using collectErrors
      _log.warning(
        'Notification publishing completed with errors for $notificationType [$correlationId]. See AggregateException.',
      );
      rethrow;
    } catch (e, s) {
      // Catch unexpected errors from the dispatcher logic itself
      _log.severe(
        'Unexpected error during notification dispatch process for $notificationType [$correlationId]: $e',
        e,
        s,
      );
      // Decide whether to rethrow - depends on desired robustness of publish.
      // Generally, publish shouldn't bring down the app unless critical.
      // Consider rethrowing only if it's a configuration-level error? For now, absorb.
    }
  }

  @override
  List<PipelineComponentInfo> getPipelinePlan<TResponse>(
    Request<TResponse> request,
  ) {
    // Implement the logic discussed previously, using _log for internal steps
    final List<PipelineComponentInfo> plan = [];
    final requestType = request.runtimeType;
    final correlationId = request.hashCode;
    _log.fine('Calculating pipeline plan for $requestType [$correlationId]');

    // Find and Sort Behaviors
    try {
      final applicableRegistrations = _registry
          .findApplicableBehaviorRegistrations(request);
      applicableRegistrations.sort((a, b) => a.order.compareTo(b.order));

      for (final reg in applicableRegistrations) {
        Type componentType = Object; // Placeholder
        try {
          // TODO: Attempt instantiation ONLY FOR TYPE - risky, replace if better method found
          componentType = reg.factory().runtimeType;
        } catch (e, s) {
          _log.warning(
            'Could not determine behavior type via instantiation for plan [$correlationId] for registration "${reg.description}". Error: $e',
            e,
            s,
          );
          componentType = dynamic;
        }
        plan.add(
          PipelineComponentInfo(
            order: reg.order,
            description: reg.description,
            componentType: componentType,
            isHandler: false,
          ),
        );
      }
      _log.finer(
        'Found ${plan.length} applicable behaviors for plan [$correlationId].',
      );
    } catch (e, s) {
      _log.warning(
        'Error finding/sorting behaviors during plan calculation for $requestType [$correlationId]',
        e,
        s,
      );
    }

    // Find Handler
    try {
      final handlerFactory =
          _registry.findHandlerFactory(requestType) ??
          _registry.findStreamHandlerFactory(requestType);

      if (handlerFactory != null) {
        Type componentType = Object;
        String description = 'Handler (Type Unknown)';
        try {
          // Attempt instantiation ONLY FOR TYPE - risky
          final tempHandler = handlerFactory();
          componentType = tempHandler.runtimeType;
          description = componentType.toString();
          _log.finer('Found handler $componentType for plan [$correlationId].');
        } catch (e, s) {
          _log.warning(
            'Could not instantiate handler factory for plan calculation type determination for $requestType [$correlationId]',
            e,
            s,
          );
          description = 'Handler (Type Unknown - Instantiation Failed)';
          componentType = dynamic;
        }
        plan.add(
          PipelineComponentInfo(
            order: 99999,
            description: description,
            componentType: componentType,
            isHandler: true,
          ),
        );
      } else {
        _log.warning(
          'No handler found for plan calculation for $requestType [$correlationId]',
        );
        plan.add(
          PipelineComponentInfo(
            order: 99999,
            description: 'Handler (Not Found)',
            componentType: Object,
            isHandler: true,
          ),
        );
      }
    } catch (e, s) {
      _log.warning(
        'Error finding handler during plan calculation for $requestType [$correlationId]',
        e,
        s,
      );
    }

    _log.fine(
      'Finished calculating pipeline plan for $requestType [$correlationId] with ${plan.length} steps.',
    );
    return plan;
  }
}
